import { Constants } from '../../common/constants/Constants';
import httpUtil from '../../common/utils/HttpUtil';
import { CartItem } from '../../models/CartModel';
import { preferences } from '@kit.ArkData';
import { common } from '@kit.AbilityKit';

@Component
export struct CartPage {
  @State cartList: CartItem[] = [];
  @State isLoading: boolean = true;
  @State isAllSelected: boolean = false;

  aboutToAppear(): void {
    this.loadCartData();
  }

  // è·å–Token
  private async getToken(): Promise<string> {
    try {
      const context = getContext(this) as common.UIAbilityContext;
      const prefs = preferences.getPreferencesSync(context, { name: 'mall_app_prefs' });
      const token = prefs.getSync(Constants.USER_TOKEN, '') as string;
      return token;
    } catch (error) {
      console.error('è·å–Tokenå¤±è´¥:', JSON.stringify(error));
      return '';
    }
  }

  // åŠ è½½è´­ç‰©è½¦æ•°æ®
  private async loadCartData(): Promise<void> {
    this.isLoading = true;
    try {
      const token = await this.getToken();
      if (!token) {
        console.warn('æœªç™»å½•ï¼Œæ— æ³•è·å–è´­ç‰©è½¦');
        this.isLoading = false;
        return;
      }

      const response = await httpUtil.get<CartItem[]>(`${Constants.API_BASE_URL}/member/cart`, token);
      if (response.code === '1' && response.result) {
        this.cartList = response.result;
        this.updateAllSelectedState();
      }
    } catch (error) {
      console.error('åŠ è½½è´­ç‰©è½¦å¤±è´¥:', JSON.stringify(error));
    } finally {
      this.isLoading = false;
    }
  }

  // æ›´æ–°å…¨é€‰çŠ¶æ€
  private updateAllSelectedState(): void {
    if (this.cartList.length === 0) {
      this.isAllSelected = false;
    } else {
      this.isAllSelected = this.cartList.every(item => item.selected);
    }
  }

  // è®¡ç®—é€‰ä¸­å•†å“æ•°é‡
  private getSelectedCount(): number {
    return this.cartList.filter(item => item.selected).reduce((sum, item) => sum + item.count, 0);
  }

  // è®¡ç®—é€‰ä¸­å•†å“æ€»ä»·
  private getSelectedTotalPrice(): string {
    const total = this.cartList
      .filter(item => item.selected)
      .reduce((sum, item) => sum + parseFloat(item.nowPrice) * item.count, 0);
    return total.toFixed(2);
  }

  // åˆ‡æ¢å•†å“é€‰ä¸­çŠ¶æ€
  private toggleItemSelected(index: number): void {
    this.cartList[index].selected = !this.cartList[index].selected;
    this.updateAllSelectedState();
  }

  // åˆ‡æ¢å…¨é€‰
  private toggleAllSelected(): void {
    this.isAllSelected = !this.isAllSelected;
    this.cartList.forEach(item => {
      item.selected = this.isAllSelected;
    });
  }

  // ä¿®æ”¹å•†å“æ•°é‡
  private updateItemCount(index: number, delta: number): void {
    const newCount = this.cartList[index].count + delta;
    if (newCount >= 1 && newCount <= this.cartList[index].stock) {
      this.cartList[index].count = newCount;
    }
  }

  // ç©ºè´­ç‰©è½¦æç¤º
  @Builder
  EmptyCart() {
    Column() {
      Text('ğŸ›’')
        .fontSize(60)
        .margin({ top: 100 })

      Text('è´­ç‰©è½¦æ˜¯ç©ºçš„')
        .fontSize(16)
        .fontColor(Constants.TEXT_HINT)
        .margin({ top: 20 })

      Text('å¿«å»æŒ‘é€‰å¿ƒä»ªçš„å•†å“å§~')
        .fontSize(14)
        .fontColor(Constants.TEXT_HINT)
        .margin({ top: 8 })
    }
    .width('100%')
    .height('100%')
    .justifyContent(FlexAlign.Start)
    .alignItems(HorizontalAlign.Center)
  }

  // è´­ç‰©è½¦å•†å“é¡¹
  @Builder
  CartItemView(item: CartItem, index: number) {
    Row() {
      // é€‰æ‹©æ¡†
      Checkbox()
        .select(item.selected)
        .selectedColor(Constants.PRIMARY_COLOR)
        .onChange((value: boolean) => {
          this.toggleItemSelected(index);
        })
        .margin({ right: 12 })

      // å•†å“å›¾ç‰‡
      Image(item.picture)
        .width(80)
        .height(80)
        .borderRadius(8)
        .objectFit(ImageFit.Cover)

      // å•†å“ä¿¡æ¯
      Column() {
        Text(item.name)
          .fontSize(14)
          .fontColor(Constants.TEXT_PRIMARY)
          .maxLines(2)
          .textOverflow({ overflow: TextOverflow.Ellipsis })

        if (item.attrsText) {
          Text(item.attrsText)
            .fontSize(12)
            .fontColor(Constants.TEXT_HINT)
            .margin({ top: 4 })
            .maxLines(1)
        }

        Row() {
          // ä»·æ ¼
          Row() {
            Text('Â¥')
              .fontSize(12)
              .fontColor(Constants.PRIMARY_COLOR)
            Text(item.nowPrice)
              .fontSize(16)
              .fontWeight(FontWeight.Bold)
              .fontColor(Constants.PRIMARY_COLOR)
          }

          Blank()

          // æ•°é‡æ§åˆ¶
          Row() {
            Text('-')
              .fontSize(18)
              .fontColor(item.count <= 1 ? Constants.TEXT_HINT : Constants.TEXT_PRIMARY)
              .width(28)
              .height(28)
              .textAlign(TextAlign.Center)
              .backgroundColor('#F5F5F5')
              .borderRadius(4)
              .onClick(() => {
                this.updateItemCount(index, -1);
              })

            Text(item.count.toString())
              .fontSize(14)
              .width(40)
              .textAlign(TextAlign.Center)

            Text('+')
              .fontSize(18)
              .fontColor(item.count >= item.stock ? Constants.TEXT_HINT : Constants.TEXT_PRIMARY)
              .width(28)
              .height(28)
              .textAlign(TextAlign.Center)
              .backgroundColor('#F5F5F5')
              .borderRadius(4)
              .onClick(() => {
                this.updateItemCount(index, 1);
              })
          }
        }
        .width('100%')
        .margin({ top: 8 })
      }
      .layoutWeight(1)
      .alignItems(HorizontalAlign.Start)
      .margin({ left: 12 })
    }
    .width('100%')
    .padding(Constants.PADDING_NORMAL)
    .backgroundColor(Color.White)
    .borderRadius(Constants.BORDER_RADIUS)
    .margin({ bottom: 12 })
  }

  // åº•éƒ¨ç»“ç®—æ 
  @Builder
  BottomBar() {
    Row() {
      // å…¨é€‰
      Row() {
        Checkbox()
          .select(this.isAllSelected)
          .selectedColor(Constants.PRIMARY_COLOR)
          .onChange(() => {
            this.toggleAllSelected();
          })

        Text('å…¨é€‰')
          .fontSize(14)
          .fontColor(Constants.TEXT_PRIMARY)
          .margin({ left: 8 })
      }

      Blank()

      // åˆè®¡
      Row() {
        Text('åˆè®¡ï¼š')
          .fontSize(14)
          .fontColor(Constants.TEXT_PRIMARY)
        Text('Â¥')
          .fontSize(12)
          .fontColor(Constants.PRIMARY_COLOR)
        Text(this.getSelectedTotalPrice())
          .fontSize(18)
          .fontWeight(FontWeight.Bold)
          .fontColor(Constants.PRIMARY_COLOR)
      }

      // ç»“ç®—æŒ‰é’®
      Button(`ç»“ç®—(${this.getSelectedCount()})`)
        .height(40)
        .fontSize(14)
        .fontColor(Color.White)
        .backgroundColor(Constants.PRIMARY_COLOR)
        .borderRadius(20)
        .margin({ left: 16 })
        .enabled(this.getSelectedCount() > 0)
    }
    .width('100%')
    .height(60)
    .padding({ left: Constants.PADDING_NORMAL, right: Constants.PADDING_NORMAL })
    .backgroundColor(Color.White)
    .shadow({ radius: 4, color: '#1A000000', offsetY: -2 })
  }

  build() {
    Column() {
      // æ ‡é¢˜æ 
      Row() {
        Text('è´­ç‰©è½¦')
          .fontSize(18)
          .fontWeight(FontWeight.Bold)
          .fontColor(Constants.TEXT_PRIMARY)
      }
      .width('100%')
      .height(50)
      .justifyContent(FlexAlign.Center)
      .backgroundColor(Color.White)

      if (this.cartList.length === 0) {
        // ç©ºè´­ç‰©è½¦
        this.EmptyCart()
      } else {
        // è´­ç‰©è½¦åˆ—è¡¨
        List() {
          ForEach(this.cartList, (item: CartItem, index: number) => {
            ListItem() {
              this.CartItemView(item, index)
            }
          })
        }
        .layoutWeight(1)
        .padding({ left: Constants.PADDING_NORMAL, right: Constants.PADDING_NORMAL, top: 12 })
        .backgroundColor(Constants.BACKGROUND_COLOR)

        // åº•éƒ¨ç»“ç®—æ 
        this.BottomBar()
      }
    }
    .width('100%')
    .height('100%')
    .backgroundColor(Constants.BACKGROUND_COLOR)
  }
}
